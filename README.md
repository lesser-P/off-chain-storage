### 链下存储基础

链下存储的理念实际上是采用混合方。我们只在链上存储合约状态的哈希值。在链下跟踪完整状态，并在与合约交互时将其传递回来。因此，与通常的内连声明每个存储变量的方式不同，我们改为：

1. 在“状态对象”struct 中声明状态字段
2. 将状态对象的哈希值存储在链上。
3. 要求用户在依赖状态的每次交互中传入完整的状态对象。
4. 验证传入的状态对象哈希与我们存储的哈希是否匹配。
5. 对于需要读取这些存储字段的交互：
   1. 直接从`calldata`或`memory`读取数据，与从存储中读取相比，这种方式成本非常低廉。
6. 对于需要写入这些存储字段的交互：
   1. 根据需要，更新在（内存中的）状态对象中的字段
   2. 计算新的状态对象哈希并更新链上哈希
   3. 以事件的形式发出（或返回）更新后的状态对象，这样用户可以获取它并将其传递到下一个交互中。

采用这种方法，我们有可能在每次交互时将多次存储读写操作合并为只进行一次操作

### 注意

虽然这种方法可能带来巨大的效率提升，但依赖链下数据也有一些值得注意的缺点和问题。

#### 基础设备负担

由于你的合约不再将完整的状态变量存储在存储器中，您的 dapp 将需要某些链下基础架构来获取合约交互的完整状态对象。幸运的是，因为我们发出包含完整对象的事件，在存档节点（例如，Alchemy）使用类似`eth_getLogs`的方法上获取最新状态对象来说是相当简单的。如果没有存档节点的访问权限，您可以启动一个服务来在事件发生时消费并缓存这些对象。

#### 可组合性

其他合约无法在纯链上环境中构建在您的协议之上。发起交易的外部账户需要向合约提供有效的链下状态对象。根据您的协议在整个流程中所处的位置，这种模式可能并没有听起来那么破坏性，因为许多协议（尤其是 DeFi 领域）已经依赖于链下组件以实现高效的使用（例如，Uniswap 路由池）

#### 交易冲突/状态过期

如果需要相同状态对象的交互足够频繁，那么可能会出现两个挂起的交易尝试更新/与同一状态对象交互的情况，这会导致第二个交易失败，因为状态哈希将不再与存储的哈希值匹配。缓解这个现象的一种方法是将您的状态对象分成按照频繁一起修改进行分组，这样不相关的交互就不会影响彼此的状态。这也可以是有意为之，以损害其他用户。在拍卖示例中，当前最高处出价者可以通过使用超出更高价者 1wei 增量的方式来保持其最高出价，改进的版本可能需要连续的出价有一个最小的百分比增量，以对这种行为产生抑制成本。

#### 状态对象约束

我们在每个需要状态对象的函数中对其进行哈希处理。这也带来一些成本，随着状态对象大小的增加而增加。出于这个原因，不建议在状态对象中存储大型数组，但是您可以隐式地使用默克尔证明以在恒定空间内实现相同效果。此外映射是仅限`storage`的结构，不容易在链下状态对象中编码，尽管你可以通过反转数据结构来规避这一问题（例如，使用状态对象的映射而不是具有映射的状态对象）
